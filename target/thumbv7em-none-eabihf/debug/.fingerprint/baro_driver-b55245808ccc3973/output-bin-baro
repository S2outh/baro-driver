{"$message_type":"diagnostic","message":"cannot find type `I2C1` in module `$crate::interrupt::typelevel`","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":767,"byte_end":771,"line_start":23,"line_end":23,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"    I2C1 => i2c::EventInterruptHandler<peripherals::I2C1>,  i2c::ErrorInterruptHandler<peripherals::I2C1>;","highlight_start":5,"highlight_end":9}],"label":"not found in `$crate::interrupt::typelevel`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":59,"byte_end":59,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use baro_driver::hscmrnn030pd2a3::*;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::peripherals::I2C1;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":59,"byte_end":59,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use baro_driver::hscmrnn030pd2a3::*;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use embassy_stm32::peripherals::I2C1;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `I2C1` in module `$crate::interrupt::typelevel`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:23:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     I2C1 => i2c::EventInterruptHandler<peripherals::I2C1>,  i2c::ErrorInterruptHandler<periphera\u001b[1m\u001b[94m...\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in `$crate::interrupt::typelevel`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these structs\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 5\u001b[0m \u001b[92m+ use crate::peripherals::I2C1;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 5\u001b[0m \u001b[92m+ use embassy_stm32::peripherals::I2C1;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `task`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":206,"byte_end":210,"line_start":7,"line_end":7,"column_start":33,"column_end":37,"is_primary":true,"text":[{"text":"use embassy_executor::{Spawner, task}; //Importiert spawner (Handel mit dem du async Tasks startest)","highlight_start":33,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":204,"byte_end":210,"line_start":7,"line_end":7,"column_start":31,"column_end":37,"is_primary":true,"text":[{"text":"use embassy_executor::{Spawner, task}; //Importiert spawner (Handel mit dem du async Tasks startest)","highlight_start":31,"highlight_end":37}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":196,"byte_end":197,"line_start":7,"line_end":7,"column_start":23,"column_end":24,"is_primary":true,"text":[{"text":"use embassy_executor::{Spawner, task}; //Importiert spawner (Handel mit dem du async Tasks startest)","highlight_start":23,"highlight_end":24}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":210,"byte_end":211,"line_start":7,"line_end":7,"column_start":37,"column_end":38,"is_primary":true,"text":[{"text":"use embassy_executor::{Spawner, task}; //Importiert spawner (Handel mit dem du async Tasks startest)","highlight_start":37,"highlight_end":38}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `task`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:7:33\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use embassy_executor::{Spawner, task}; //Importiert spawner (Handel mit dem du async Tasks startest)\n  \u001b[1m\u001b[94m|\u001b[0m                                 \u001b[1m\u001b[33m^^^^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"unused import: `embassy_stm32::Peri`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":279,"byte_end":298,"line_start":8,"line_end":8,"column_start":5,"column_end":24,"is_primary":true,"text":[{"text":"use embassy_stm32::Peri;","highlight_start":5,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":275,"byte_end":300,"line_start":8,"line_end":9,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use embassy_stm32::Peri;","highlight_start":1,"highlight_end":25},{"text":"use embassy_stm32::peripherals::{PB8, PB9, I2C1};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `embassy_stm32::Peri`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:8:5\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use embassy_stm32::Peri;\n  \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused imports: `I2C1`, `PB8`, and `PB9`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":333,"byte_end":336,"line_start":9,"line_end":9,"column_start":34,"column_end":37,"is_primary":true,"text":[{"text":"use embassy_stm32::peripherals::{PB8, PB9, I2C1};","highlight_start":34,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":338,"byte_end":341,"line_start":9,"line_end":9,"column_start":39,"column_end":42,"is_primary":true,"text":[{"text":"use embassy_stm32::peripherals::{PB8, PB9, I2C1};","highlight_start":39,"highlight_end":42}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":343,"byte_end":347,"line_start":9,"line_end":9,"column_start":44,"column_end":48,"is_primary":true,"text":[{"text":"use embassy_stm32::peripherals::{PB8, PB9, I2C1};","highlight_start":44,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":300,"byte_end":350,"line_start":9,"line_end":10,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use embassy_stm32::peripherals::{PB8, PB9, I2C1};","highlight_start":1,"highlight_end":50},{"text":"use embassy_stm32::{bind_interrupts, i2c, peripherals};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused imports: `I2C1`, `PB8`, and `PB9`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:9:34\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m9\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use embassy_stm32::peripherals::{PB8, PB9, I2C1};\n  \u001b[1m\u001b[94m|\u001b[0m                                  \u001b[1m\u001b[33m^^^\u001b[0m  \u001b[1m\u001b[33m^^^\u001b[0m  \u001b[1m\u001b[33m^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused imports: `Error`, `Flex`, `I2c`, `Level`, `Output`, `Pull`, `Speed`, `exti::ExtiInput`, and `mode::Async`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":431,"byte_end":446,"line_start":12,"line_end":12,"column_start":5,"column_end":20,"is_primary":true,"text":[{"text":"    exti::ExtiInput,","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":459,"byte_end":463,"line_start":13,"line_end":13,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"    gpio::{Flex, Level, Output, Pull, Speed},","highlight_start":12,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":465,"byte_end":470,"line_start":13,"line_end":13,"column_start":18,"column_end":23,"is_primary":true,"text":[{"text":"    gpio::{Flex, Level, Output, Pull, Speed},","highlight_start":18,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":472,"byte_end":478,"line_start":13,"line_end":13,"column_start":25,"column_end":31,"is_primary":true,"text":[{"text":"    gpio::{Flex, Level, Output, Pull, Speed},","highlight_start":25,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":480,"byte_end":484,"line_start":13,"line_end":13,"column_start":33,"column_end":37,"is_primary":true,"text":[{"text":"    gpio::{Flex, Level, Output, Pull, Speed},","highlight_start":33,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":486,"byte_end":491,"line_start":13,"line_end":13,"column_start":39,"column_end":44,"is_primary":true,"text":[{"text":"    gpio::{Flex, Level, Output, Pull, Speed},","highlight_start":39,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":525,"byte_end":530,"line_start":14,"line_end":14,"column_start":32,"column_end":37,"is_primary":true,"text":[{"text":"    i2c::{Config as I2cconfig, Error, I2c},","highlight_start":32,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":532,"byte_end":535,"line_start":14,"line_end":14,"column_start":39,"column_end":42,"is_primary":true,"text":[{"text":"    i2c::{Config as I2cconfig, Error, I2c},","highlight_start":39,"highlight_end":42}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":542,"byte_end":553,"line_start":15,"line_end":15,"column_start":5,"column_end":16,"is_primary":true,"text":[{"text":"    mode::Async,","highlight_start":5,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused imports","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":431,"byte_end":498,"line_start":12,"line_end":14,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    exti::ExtiInput,","highlight_start":5,"highlight_end":21},{"text":"    gpio::{Flex, Level, Output, Pull, Speed},","highlight_start":1,"highlight_end":46},{"text":"    i2c::{Config as I2cconfig, Error, I2c},","highlight_start":1,"highlight_end":5}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":523,"byte_end":535,"line_start":14,"line_end":14,"column_start":30,"column_end":42,"is_primary":true,"text":[{"text":"    i2c::{Config as I2cconfig, Error, I2c},","highlight_start":30,"highlight_end":42}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":503,"byte_end":504,"line_start":14,"line_end":14,"column_start":10,"column_end":11,"is_primary":true,"text":[{"text":"    i2c::{Config as I2cconfig, Error, I2c},","highlight_start":10,"highlight_end":11}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":535,"byte_end":536,"line_start":14,"line_end":14,"column_start":42,"column_end":43,"is_primary":true,"text":[{"text":"    i2c::{Config as I2cconfig, Error, I2c},","highlight_start":42,"highlight_end":43}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":536,"byte_end":553,"line_start":14,"line_end":15,"column_start":43,"column_end":16,"is_primary":true,"text":[{"text":"    i2c::{Config as I2cconfig, Error, I2c},","highlight_start":43,"highlight_end":44},{"text":"    mode::Async,","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused imports: `Error`, `Flex`, `I2c`, `Level`, `Output`, `Pull`, `Speed`, `exti::ExtiInput`, and `mode::Async`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:12:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m12\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     exti::ExtiInput,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m13\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     gpio::{Flex, Level, Output, Pull, Speed},\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[33m^^^^\u001b[0m  \u001b[1m\u001b[33m^^^^^\u001b[0m  \u001b[1m\u001b[33m^^^^^^\u001b[0m  \u001b[1m\u001b[33m^^^^\u001b[0m  \u001b[1m\u001b[33m^^^^^\u001b[0m\n\u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     i2c::{Config as I2cconfig, Error, I2c},\n   \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[33m^^^^^\u001b[0m  \u001b[1m\u001b[33m^^^\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     mode::Async,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `embassy_time::Timer`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":579,"byte_end":598,"line_start":18,"line_end":18,"column_start":5,"column_end":24,"is_primary":true,"text":[{"text":"use embassy_time::Timer; // Importiert Timer, die zeitbasierte async API von Embassy","highlight_start":5,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":575,"byte_end":599,"line_start":18,"line_end":18,"column_start":1,"column_end":25,"is_primary":true,"text":[{"text":"use embassy_time::Timer; // Importiert Timer, die zeitbasierte async API von Embassy","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `embassy_time::Timer`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:18:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m18\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use embassy_time::Timer; // Importiert Timer, die zeitbasierte async API von Embassy\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"variable does not need to be mutable","code":{"code":"unused_mut","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":944,"byte_end":949,"line_start":28,"line_end":28,"column_start":9,"column_end":14,"is_primary":true,"text":[{"text":"    let mut p = embassy_stm32::init(Default::default());","highlight_start":9,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove this `mut`","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":944,"byte_end":948,"line_start":28,"line_end":28,"column_start":9,"column_end":13,"is_primary":true,"text":[{"text":"    let mut p = embassy_stm32::init(Default::default());","highlight_start":9,"highlight_end":13}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: variable does not need to be mutable\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:28:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m28\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let mut p = embassy_stm32::init(Default::default());\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m----\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94mhelp: remove this `mut`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 1 previous error; 6 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 1 previous error; 6 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"For more information about this error, try `rustc --explain E0425`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about this error, try `rustc --explain E0425`.\u001b[0m\n"}
